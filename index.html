<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Survivor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        canvas {
            box-shadow: 0 0 20px #ff00ff;
            cursor: crosshair;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-top {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #xp-bar-container {
            width: 100%;
            height: 20px;
            background: #222;
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
        }

        #xp-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff00, #adff2f);
            box-shadow: 0 0 10px #00ff00;
            transition: width 0.2s;
        }

        .stat-row {
            display: flex;
            gap: 20px;
            font-size: 14px;
            text-shadow: 0 0 5px cyan;
        }

        /* Modal Styles */
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0ff;
            box-shadow: 0 0 30px #0ff;
            padding: 30px;
            text-align: center;
            pointer-events: auto;
            display: none;
            min-width: 400px;
            border-radius: 8px;
        }

        .modal h1 {
            margin-top: 0;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }

        .upgrade-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .upgrade-card {
            background: #111;
            border: 1px solid #0ff;
            padding: 15px;
            cursor: pointer;
            transition: 0.2s;
            text-align: left;
        }

        .upgrade-card:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 15px #0ff;
        }

        .upgrade-card h3 { margin: 0 0 5px 0; }
        .upgrade-card small { font-size: 0.8em; opacity: 0.8; }

        #game-over-screen h2 { color: #ff0000; text-shadow: 0 0 20px red; font-size: 3em; }
        .btn {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 20px;
        }
        .btn:hover { background: #0ff; color: #000; box-shadow: 0 0 10px #0ff; }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stat-row">
                <span id="level-display">LVL: 1</span>
                <span id="timer-display">00:00</span>
                <span id="hp-display">HP: 100</span>
            </div>
            <div id="xp-bar-container">
                <div id="xp-bar-fill"></div>
            </div>
        </div>

        <!-- Level Up Modal -->
        <div id="level-up-modal" class="modal">
            <h1>SYSTEM UPGRADE</h1>
            <p>Select an enhancement:</p>
            <div class="upgrade-container" id="upgrade-list">
                <!-- Options injected here -->
            </div>
        </div>

        <!-- Game Over Modal -->
        <div id="game-over-screen" class="modal">
            <h2>CRITICAL FAILURE</h2>
            <p id="final-stats"></p>
            <button class="btn" onclick="location.reload()">REBOOT SYSTEM</button>
        </div>
    </div>

<script>
/** 
 * GAME ENGINE & CONSTANTS
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Auto-resize
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Game State
const STATE = {
    PLAYING: 0,
    LEVEL_UP: 1,
    GAME_OVER: 2
};
let currentState = STATE.PLAYING;
let frame = 0;
let timeElapsed = 0; // Seconds

// Inputs
const keys = { w: false, a: false, s: false, d: false };
window.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = true; });
window.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });

/**
 * ENTITIES
 */
const camera = { x: 0, y: 0 };

const player = {
    x: 0, y: 0,
    radius: 15,
    color: '#00ffff',
    speed: 3,
    maxHp: 100,
    hp: 100,
    level: 1,
    xp: 0,
    xpToNext: 10,
    magnetRange: 80,
    invulnTimer: 0,
    angle: 0
};

let enemies = [];
let particles = []; // XP Gems
let projectiles = [];
let floatingTexts = [];
let trails = []; // For firewall

/**
 * UPGRADE SYSTEM DEFINITIONS
 */
const UPGRADES = {
    pulse: {
        id: 'pulse', name: 'Pulse Blaster', type: 'weapon',
        desc: 'Shoots nearest enemy rapidly.',
        level: 1, maxLevel: 5,
        cooldown: 60, timer: 0, damage: 25, speed: 10
    },
    orbit: {
        id: 'orbit', name: 'Neon Orbit', type: 'weapon',
        desc: 'Orbs circle you to protect.',
        level: 0, maxLevel: 5,
        count: 1, speed: 0.05, dist: 60, damage: 15,
        orbs: [] // Stores current orbiters
    },
    bass: {
        id: 'bass', name: 'Bass Wave', type: 'weapon',
        desc: 'Shockwave damages nearby foes.',
        level: 0, maxLevel: 5,
        cooldown: 180, timer: 0, radius: 100, damage: 40
    },
    lance: {
        id: 'lance', name: 'Laser Lance', type: 'weapon',
        desc: 'Fires a piercing beam.',
        level: 0, maxLevel: 5,
        cooldown: 120, timer: 0, width: 20, damage: 30, duration: 15
    },
    rear: {
        id: 'rear', name: 'Rear Guard', type: 'weapon',
        desc: 'Shoots behind you.',
        level: 0, maxLevel: 5,
        cooldown: 70, timer: 0, damage: 20, speed: 8
    },
    homing: {
        id: 'homing', name: 'Homing Missile', type: 'weapon',
        desc: 'Slowly tracks enemies.',
        level: 0, maxLevel: 5,
        cooldown: 90, timer: 0, damage: 35, speed: 4
    },
    spread: {
        id: 'spread', name: 'Spread Shot', type: 'weapon',
        desc: 'Fires 3 bullets in a cone.',
        level: 0, maxLevel: 5,
        cooldown: 80, timer: 0, damage: 15, speed: 9
    },
    drain: {
        id: 'drain', name: 'Data Drain', type: 'passive',
        desc: 'Increases XP pickup range.',
        level: 0, maxLevel: 3,
        value: 50
    },
    overclock: {
        id: 'overclock', name: 'Overclock', type: 'passive',
        desc: 'Increases movement speed.',
        level: 0, maxLevel: 3,
        value: 1
    },
    firewall: {
        id: 'firewall', name: 'Firewall', type: 'weapon', // Treated as weapon for update loop
        desc: 'Leaves a damaging trail.',
        level: 0, maxLevel: 5,
        cooldown: 20, timer: 0, damage: 10, duration: 120
    }
};

const upgradeKeys = Object.keys(UPGRADES);

/**
 * GAME LOGIC
 */

function spawnEnemy() {
    // Spawn outside camera view
    const angle = Math.random() * Math.PI * 2;
    const dist = Math.max(canvas.width, canvas.height) / 1.5 + 50;
    
    const type = Math.random() > 0.8 ? 'charger' : 'chaser';
    const hpMult = 1 + (timeElapsed / 60); // Scaling difficulty
    
    enemies.push({
        x: player.x + Math.cos(angle) * dist,
        y: player.y + Math.sin(angle) * dist,
        type: type,
        radius: type === 'charger' ? 20 : 12,
        hp: (type === 'charger' ? 50 : 20) * hpMult,
        maxHp: (type === 'charger' ? 50 : 20) * hpMult,
        speed: type === 'charger' ? 1.5 : 2 + (Math.random() * 0.5),
        color: type === 'charger' ? '#ff00aa' : '#aa00ff',
        damage: type === 'charger' ? 20 : 10,
        pushX: 0, pushY: 0
    });
}

function getNearestEnemy(x, y, range) {
    let nearest = null;
    let minDist = range * range;
    for(let e of enemies) {
        let dx = e.x - x;
        let dy = e.y - y;
        let dist = dx*dx + dy*dy;
        if(dist < minDist) {
            minDist = dist;
            nearest = e;
        }
    }
    return nearest;
}

function updateWeapons() {
    // 1. Pulse Blaster
    if(UPGRADES.pulse.level > 0) {
        UPGRADES.pulse.timer--;
        if(UPGRADES.pulse.timer <= 0) {
            const target = getNearestEnemy(player.x, player.y, 600);
            if(target) {
                UPGRADES.pulse.timer = UPGRADES.pulse.cooldown;
                const angle = Math.atan2(target.y - player.y, target.x - player.x);
                projectiles.push({
                    x: player.x, y: player.y,
                    dx: Math.cos(angle) * UPGRADES.pulse.speed,
                    dy: Math.sin(angle) * UPGRADES.pulse.speed,
                    life: 100, radius: 5, color: '#0ff',
                    damage: UPGRADES.pulse.damage, pierce: 0, type: 'bullet'
                });
            }
        }
    }

    // 2. Neon Orbit
    if(UPGRADES.orbit.level > 0) {
        // Logic handles in draw/render for position, damage here
        const orbit = UPGRADES.orbit;
        const time = Date.now() / 1000;
        for(let i=0; i<orbit.count; i++) {
            const angle = time * (1 + orbit.speed) + (i * (Math.PI * 2 / orbit.count));
            const ox = player.x + Math.cos(angle) * orbit.dist;
            const oy = player.y + Math.sin(angle) * orbit.dist;
            
            // Collision for orb
            enemies.forEach(e => {
                const dx = e.x - ox;
                const dy = e.y - oy;
                if(dx*dx + dy*dy < (e.radius + 10)**2) {
                   damageEnemy(e, orbit.damage * 0.1); // Tick damage low
                }
            });
        }
    }

    // 3. Bass Wave
    if(UPGRADES.bass.level > 0) {
        UPGRADES.bass.timer--;
        if(UPGRADES.bass.timer <= 0) {
            UPGRADES.bass.timer = UPGRADES.bass.cooldown;
            // Visual effect handled in drawing
            projectiles.push({
                x: player.x, y: player.y,
                life: 20, type: 'shockwave',
                radius: UPGRADES.bass.radius,
                damage: UPGRADES.bass.damage
            });
        }
    }

    // 4. Laser Lance
    if(UPGRADES.lance.level > 0) {
        UPGRADES.lance.timer--;
        if(UPGRADES.lance.timer <= 0) {
            UPGRADES.lance.timer = UPGRADES.lance.cooldown;
            // Shoots horizontal beam
            projectiles.push({
                x: player.x, y: player.y,
                life: UPGRADES.lance.duration, type: 'beam',
                width: UPGRADES.lance.width,
                damage: UPGRADES.lance.damage
            });
        }
    }

    // 5. Rear Guard
    if(UPGRADES.rear.level > 0) {
        UPGRADES.rear.timer--;
        if(UPGRADES.rear.timer <= 0) {
            UPGRADES.rear.timer = UPGRADES.rear.cooldown;
            // Determine rear angle based on movement or default
            let angle = 0;
            if(keys.w) angle = Math.PI/2; // Behind is Down
            else if(keys.s) angle = -Math.PI/2; // Behind is Up
            else if(keys.a) angle = 0; // Behind is Right
            else if(keys.d) angle = Math.PI; // Behind is Left
            else angle = Math.random() * Math.PI * 2;

            projectiles.push({
                x: player.x, y: player.y,
                dx: Math.cos(angle) * UPGRADES.rear.speed,
                dy: Math.sin(angle) * UPGRADES.rear.speed,
                life: 80, radius: 8, color: '#ffaa00',
                damage: UPGRADES.rear.damage, pierce: 2, type: 'bullet'
            });
        }
    }

    // 6. Homing Missiles
    if(UPGRADES.homing.level > 0) {
        UPGRADES.homing.timer--;
        if(UPGRADES.homing.timer <= 0) {
            UPGRADES.homing.timer = UPGRADES.homing.cooldown;
            const angle = Math.random() * Math.PI * 2;
            projectiles.push({
                x: player.x, y: player.y,
                dx: Math.cos(angle) * UPGRADES.homing.speed,
                dy: Math.sin(angle) * UPGRADES.homing.speed,
                life: 150, radius: 6, color: '#ff0055',
                damage: UPGRADES.homing.damage, pierce: 0, type: 'homing',
                speed: UPGRADES.homing.speed
            });
        }
    }

    // 7. Spread Shot
    if(UPGRADES.spread.level > 0) {
        UPGRADES.spread.timer--;
        if(UPGRADES.spread.timer <= 0) {
            UPGRADES.spread.timer = UPGRADES.spread.cooldown;
            const target = getNearestEnemy(player.x, player.y, 500);
            let baseAngle = 0;
            if(target) {
                baseAngle = Math.atan2(target.y - player.y, target.x - player.x);
            } else {
                baseAngle = Math.random() * Math.PI * 2;
            }

            [-0.3, 0, 0.3].forEach(offset => {
                projectiles.push({
                    x: player.x, y: player.y,
                    dx: Math.cos(baseAngle + offset) * UPGRADES.spread.speed,
                    dy: Math.sin(baseAngle + offset) * UPGRADES.spread.speed,
                    life: 60, radius: 4, color: '#ffff00',
                    damage: UPGRADES.spread.damage, pierce: 1, type: 'bullet'
                });
            });
        }
    }

    // 10. Firewall
    if(UPGRADES.firewall.level > 0) {
        UPGRADES.firewall.timer--;
        if(UPGRADES.firewall.timer <= 0) {
            UPGRADES.firewall.timer = UPGRADES.firewall.cooldown;
            trails.push({
                x: player.x, y: player.y,
                life: UPGRADES.firewall.duration,
                radius: 15,
                damage: UPGRADES.firewall.damage
            });
        }
    }
}

function damageEnemy(enemy, amount) {
    enemy.hp -= amount;
    floatingTexts.push({
        x: enemy.x, y: enemy.y, 
        text: Math.floor(amount), life: 30, 
        color: '#fff'
    });
    enemy.pushX = (enemy.x - player.x) * 0.1;
    enemy.pushY = (enemy.y - player.y) * 0.1;
}

function checkLevelUp() {
    if(player.xp >= player.xpToNext) {
        player.xp -= player.xpToNext;
        player.level++;
        player.xpToNext = Math.floor(player.xpToNext * 1.5);
        
        currentState = STATE.LEVEL_UP;
        showLevelUpMenu();
    }
    // Update UI Bar
    const pct = Math.min(100, (player.xp / player.xpToNext) * 100);
    document.getElementById('xp-bar-fill').style.width = pct + '%';
    document.getElementById('level-display').innerText = 'LVL: ' + player.level;
}

function generateUpgrades() {
    // Filter available
    let pool = upgradeKeys.filter(k => UPGRADES[k].level < UPGRADES[k].maxLevel);
    // Shuffle
    for (let i = pool.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    // Pick 3 (or less)
    return pool.slice(0, 3).map(k => UPGRADES[k]);
}

function showLevelUpMenu() {
    const modal = document.getElementById('level-up-modal');
    const list = document.getElementById('upgrade-list');
    list.innerHTML = '';
    
    const options = generateUpgrades();
    
    if(options.length === 0) {
        // Maxed out! Just heal
        const div = document.createElement('div');
        div.className = 'upgrade-card';
        div.innerHTML = `<h3>Full Restore</h3><small>Heal 50 HP</small>`;
        div.onclick = () => {
            player.hp = Math.min(player.maxHp, player.hp + 50);
            document.getElementById('hp-display').innerText = 'HP: ' + Math.floor(player.hp);
            modal.style.display = 'none';
            currentState = STATE.PLAYING;
        };
        list.appendChild(div);
    } else {
        options.forEach(opt => {
            const div = document.createElement('div');
            div.className = 'upgrade-card';
            const isUnlock = opt.level === 0;
            div.innerHTML = `
                <h3>${isUnlock ? 'Unlock' : 'Upgrade'} ${opt.name} ${!isUnlock ? '(Lvl ' + (opt.level+1) + ')' : ''}</h3>
                <small>${opt.desc}</small>
            `;
            div.onclick = () => applyUpgrade(opt);
            list.appendChild(div);
        });
    }
    
    modal.style.display = 'block';
}

function applyUpgrade(opt) {
    opt.level++;
    
    // Apply stats logic
    if(opt.id === 'pulse') { opt.cooldown *= 0.9; opt.damage += 10; }
    if(opt.id === 'orbit') { opt.count++; opt.speed += 0.02; }
    if(opt.id === 'bass') { opt.radius += 20; opt.cooldown -= 10; }
    if(opt.id === 'lance') { opt.width += 10; opt.damage += 10; }
    if(opt.id === 'rear') { opt.cooldown -= 5; opt.damage += 5; }
    if(opt.id === 'homing') { opt.cooldown -= 10; opt.damage += 5; }
    if(opt.id === 'spread') { opt.cooldown -= 5; opt.damage += 5; }
    if(opt.id === 'firewall') { opt.duration += 20; opt.damage += 2; }
    
    // Passives
    if(opt.id === 'drain') { player.magnetRange += opt.value; }
    if(opt.id === 'overclock') { player.speed += opt.value; }

    document.getElementById('level-up-modal').style.display = 'none';
    currentState = STATE.PLAYING;
}

function gameOver() {
    currentState = STATE.GAME_OVER;
    document.getElementById('game-over-screen').style.display = 'block';
    document.getElementById('final-stats').innerText = `You reached Level ${player.level}\nSurvived: ${document.getElementById('timer-display').innerText}`;
}

/**
 * MAIN LOOP
 */
function loop() {
    if (currentState === STATE.PLAYING) {
        update();
    }
    draw();
    requestAnimationFrame(loop);
}

function update() {
    // Timer
    frame++;
    if(frame % 60 === 0) {
        timeElapsed++;
        const mins = Math.floor(timeElapsed / 60).toString().padStart(2, '0');
        const secs = (timeElapsed % 60).toString().padStart(2, '0');
        document.getElementById('timer-display').innerText = `${mins}:${secs}`;
    }

    // Player Movement
    let dx = 0, dy = 0;
    if(keys.w) dy = -1;
    if(keys.s) dy = 1;
    if(keys.a) dx = -1;
    if(keys.d) dx = 1;

    // Normalize
    if(dx !== 0 || dy !== 0) {
        const len = Math.sqrt(dx*dx + dy*dy);
        dx /= len; dy /= len;
        player.x += dx * player.speed;
        player.y += dy * player.speed;
    }

    // Bounds
    // Let player move infinitely, camera follows.

    // Camera Follow
    camera.x = player.x - canvas.width / 2;
    camera.y = player.y - canvas.height / 2;

    // Weapon Systems
    updateWeapons();

    // Trails (Firewall)
    for(let i=trails.length-1; i>=0; i--) {
        let t = trails[i];
        t.life--;
        // Damage logic
        if(frame % 10 === 0) { // Do damage periodically
            enemies.forEach(e => {
                let dist = (e.x - t.x)**2 + (e.y - t.y)**2;
                if(dist < (t.radius + e.radius)**2) {
                    damageEnemy(e, t.damage);
                }
            });
        }
        if(t.life <= 0) trails.splice(i, 1);
    }

    // Projectiles
    for(let i=projectiles.length-1; i>=0; i--) {
        let p = projectiles[i];
        
        if(p.type === 'bullet' || p.type === 'homing') {
            if(p.type === 'homing') {
                let target = getNearestEnemy(p.x, p.y, 400);
                if(target) {
                    let angle = Math.atan2(target.y - p.y, target.x - p.x);
                    // Simple lerp for turning
                    p.dx = p.dx * 0.95 + Math.cos(angle) * p.speed * 0.05;
                    p.dy = p.dy * 0.95 + Math.sin(angle) * p.speed * 0.05;
                    // Re-normalize speed
                    let len = Math.sqrt(p.dx*p.dx + p.dy*p.dy);
                    p.dx = (p.dx / len) * p.speed;
                    p.dy = (p.dy / len) * p.speed;
                }
            }

            p.x += p.dx;
            p.y += p.dy;
            p.life--;
            
            // Collision
            let hit = false;
            for(let e of enemies) {
                let dist = (e.x - p.x)**2 + (e.y - p.y)**2;
                if(dist < (e.radius + p.radius)**2) {
                    damageEnemy(e, p.damage);
                    hit = true;
                    if(p.pierce > 0) {
                        p.pierce--;
                        hit = false; // Keep going
                    } else {
                        break;
                    }
                }
            }
            if(hit || p.life <= 0) projectiles.splice(i, 1);
        }
        else if (p.type === 'shockwave') {
            // Instant damage once
            if(p.life === 20) { // First frame
                 enemies.forEach(e => {
                    let dist = (e.x - p.x)**2 + (e.y - p.y)**2;
                    if(dist < (p.radius + e.radius)**2) {
                        damageEnemy(e, p.damage);
                    }
                });
            }
            p.life--;
            if(p.life <= 0) projectiles.splice(i, 1);
        }
        else if (p.type === 'beam') {
            // Horizontal beam relative to screen (for simplicity just left/right of player)
            // Let's make it a wide rect centered on player Y
            enemies.forEach(e => {
                // Check Y band
                if(Math.abs(e.y - p.y) < p.width) {
                    // Beam is infinite width essentially, or checks screen width
                    damageEnemy(e, p.damage * 0.1); // Continuous small dmg
                }
            });
            p.life--;
            if(p.life <= 0) projectiles.splice(i, 1);
        }
    }

    // Enemies
    if(frame % (60 - Math.min(50, Math.floor(timeElapsed/10))) === 0) {
        if(enemies.length < 200) spawnEnemy();
    }

    for(let i=enemies.length-1; i>=0; i--) {
        let e = enemies[i];
        
        // Push physics (prevent stacking)
        e.x += e.pushX;
        e.y += e.pushY;
        e.pushX *= 0.9;
        e.pushY *= 0.9;

        // Move to player
        let angle = Math.atan2(player.y - e.y, player.x - e.x);
        e.x += Math.cos(angle) * e.speed;
        e.y += Math.sin(angle) * e.speed;

        // Player Collision
        let dist = (player.x - e.x)**2 + (player.y - e.y)**2;
        if(dist < (player.radius + e.radius)**2) {
            if(player.invulnTimer <= 0) {
                player.hp -= e.damage;
                player.invulnTimer = 30;
                document.getElementById('hp-display').innerText = 'HP: ' + Math.max(0, Math.floor(player.hp));
                if(player.hp <= 0) gameOver();
            }
        }

        // Death
        if(e.hp <= 0) {
            // Drop Gem
            particles.push({x: e.x, y: e.y, val: 5 + Math.floor(timeElapsed/30)});
            enemies.splice(i, 1);
        }
    }

    if(player.invulnTimer > 0) player.invulnTimer--;

    // XP Gems
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        let dist = (player.x - p.x)**2 + (player.y - p.y)**2;
        
        // Magnet
        if(dist < player.magnetRange**2) {
            p.x += (player.x - p.x) * 0.1;
            p.y += (player.y - p.y) * 0.1;
        }

        if(dist < player.radius**2) {
            player.xp += p.val;
            particles.splice(i, 1);
            checkLevelUp();
        }
    }
    
    // Floating Text
    for(let i=floatingTexts.length-1; i>=0; i--) {
        floatingTexts[i].y -= 1;
        floatingTexts[i].life--;
        if(floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
    }
}

function draw() {
    // Clear Background
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    // Apply Camera
    ctx.translate(-camera.x, -camera.y);

    // Draw Grid (Synthwave Floor)
    ctx.strokeStyle = '#220033';
    ctx.lineWidth = 2;
    const gridSize = 100;
    // Calculate grid offset
    const startX = Math.floor(camera.x / gridSize) * gridSize;
    const startY = Math.floor(camera.y / gridSize) * gridSize;
    
    ctx.beginPath();
    for(let x = startX; x < camera.x + canvas.width + gridSize; x += gridSize) {
        ctx.moveTo(x, camera.y);
        ctx.lineTo(x, camera.y + canvas.height);
    }
    for(let y = startY; y < camera.y + canvas.height + gridSize; y += gridSize) {
        ctx.moveTo(camera.x, y);
        ctx.lineTo(camera.x + canvas.width, y);
    }
    ctx.stroke();

    // Draw Trails
    trails.forEach(t => {
        ctx.fillStyle = `rgba(255, 50, 0, ${t.life/100})`;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.radius, 0, Math.PI*2);
        ctx.fill();
    });

    // Draw XP Gems
    ctx.shadowBlur = 5;
    ctx.shadowColor = '#00ff00';
    ctx.fillStyle = '#00ff00';
    particles.forEach(p => {
        ctx.beginPath();
        ctx.rect(p.x - 3, p.y - 3, 6, 6);
        ctx.fill();
    });
    ctx.shadowBlur = 0;

    // Draw Enemies
    enemies.forEach(e => {
        ctx.shadowBlur = 10;
        ctx.shadowColor = e.color;
        ctx.strokeStyle = e.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        if(e.type === 'chaser') {
            // Triangle pointing to player
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.rotate(Math.atan2(player.y - e.y, player.x - e.x));
            ctx.moveTo(10, 0);
            ctx.lineTo(-10, 8);
            ctx.lineTo(-10, -8);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        } else {
            // Square
            ctx.rect(e.x - e.radius, e.y - e.radius, e.radius*2, e.radius*2);
            ctx.stroke();
        }
    });

    // Draw Projectiles
    projectiles.forEach(p => {
        if(p.type === 'bullet' || p.type === 'homing') {
            ctx.shadowBlur = 8;
            ctx.shadowColor = p.color;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
            ctx.fill();
        }
        else if (p.type === 'shockwave') {
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#0ff';
            ctx.strokeStyle = `rgba(0, 255, 255, ${p.life/20})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
            ctx.stroke();
        }
        else if (p.type === 'beam') {
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#f0f';
            ctx.fillStyle = `rgba(255, 0, 255, ${p.life/15})`;
            ctx.fillRect(camera.x, p.y - p.width/2, canvas.width, p.width);
        }
    });

    // Draw Orbiters
    if(UPGRADES.orbit.level > 0) {
        const orbit = UPGRADES.orbit;
        const time = Date.now() / 1000;
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#00ffff';
        ctx.fillStyle = '#fff';
        for(let i=0; i<orbit.count; i++) {
            const angle = time * (1 + orbit.speed) + (i * (Math.PI * 2 / orbit.count));
            const ox = player.x + Math.cos(angle) * orbit.dist;
            const oy = player.y + Math.sin(angle) * orbit.dist;
            ctx.beginPath();
            ctx.arc(ox, oy, 8, 0, Math.PI*2);
            ctx.fill();
        }
    }

    // Draw Player
    if(player.hp > 0) {
        ctx.shadowBlur = 20;
        ctx.shadowColor = player.color;
        ctx.fillStyle = (player.invulnTimer > 0 && Math.floor(Date.now()/50)%2===0) ? '#fff' : player.color;
        
        ctx.save();
        ctx.translate(player.x, player.y);
        // Simple rotation animation
        ctx.rotate(timeElapsed); 
        ctx.beginPath();
        ctx.moveTo(0, -player.radius);
        ctx.lineTo(player.radius, player.radius);
        ctx.lineTo(-player.radius, player.radius);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    // Floating Text
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#fff';
    ctx.font = '12px "Orbitron"';
    floatingTexts.forEach(t => {
        ctx.fillText(t.text, t.x, t.y);
    });

    ctx.restore();
}

// Start
loop();

</script>
</body>
</html>